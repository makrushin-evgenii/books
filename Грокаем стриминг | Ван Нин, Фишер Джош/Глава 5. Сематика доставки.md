### Глава 5. Сематика доставки
#### Требования к задержке в системе обнаружения мошеннических действий
#### Возвращаемся к заданию обнаружения мошеннических действий
#### О точности
#### Частичный результат
#### Новое стриминговое задание для контроля за использованием системы
#### Новое задание контроля использования системы
#### Требования к заданию контроля
#### Новые концепции: количество доставок и обработок
Количество обработок показывает, сколько раз событие было обработано компонентом. Количество доставок показывает, сколько раз результат был сгенерирован компонентом.
#### Новая концепция: семантика доставки
at-most-once - каждое событие будет обработано не более одного раза
at-least-once - каждое событие будет успешного обработано не менее одного раза
exactly once - каждое событие будет успешно обработано ровно один раз
#### Выбор семантики
at-most-once: точность не гарантирована из-за пропуска событий, усточива к сбоям, отстутствует задержка при возникновении ошибок
at-least-once: точность не гранатирована из-за дублирования события, чувствительна к сбоям, возможна задержка при возникновении ошибок
exactly-once" точность гарантирована, чувствительная к сбоям, возможна задержка при возникновении ошибок
#### "Не более одного"
Исполнители и диспетчеры событий механически передают события последующим процессам (имеется в виду, что они не сохраняют информацию о том, что куда направлено). Они просто принимают и перемещают события как можно быстрее.
#### Задание обнаружения мошеннических действий
#### "Не менее одного"
Исполнители и диспетчеры событий передают события последующим процессам, а события отслеживаются. Если событие будет потеряно, то оно отправится заново.
#### "Не менее одного" с подтверждением
После того как компонент-источник сгенерирует событие, он сохраняет его в буфере. При получении сообщения об успехе от обработчика подтверждений событие удаляется из буфера, так как оно было успешно обработано. Если компонент-источник получит сообщение об ошибке для события, он воспроизводит это событие, повторно отправляя его в задание.
#### Отслеживание событий
К всем событиям добавляются метаданные: идентификатор события и список обработчиков. Таким образом обработчик подтверждения знает, от скольки компонент он должен получить подтверждения - чтобы ститать событие полностью обработанным.
#### Управление сбоями при обработке событий
Если событие не будет обработанно одним из компонент, обработчик подтверждение запросит у источника повторную генерацию этого события.
#### Ранее обнаружение потерянных событий
#### Код подтверждения в компонентах
#### Новая концепция: контрольные точки
Позволют повторить обработку с ранее сохранённого этапа.
#### Новая концепция: состояние
#### Контрольные точки в задании контроля за использованием системы для семантики "не менее одного"
#### Контрольные точки и функции управления состоянием
#### Код управления состоянием в компоненте источника транзакций
#### Ровно один или фактически один?
Реализация семантики exactly-once допускает, что вычисления будут запущены несколько раз. Важно, что результат будет таким, если бы вычисления были запущены фактически один раз.
#### Вспомогательная концепция: идемпотентные операции
#### Наконец, "ровно один"
Как и at-leas-once обеспечивается контрольными точками. Но они создаются не только для источника, но и операторов.
#### Код управления состоянием в компоненте анализатора использования системы
#### Повторное сравнение семантик доставки
> В лямбда-архитектуре сопутствующий процесс пакетной обработки выполняется на тех же данных, чтобы получить точные результаты, но с более высокой задержкой.
#### Итоги
at-most-once - быстро, at-least-once - надежно и не сложно, exactly-once - медленно, сложно, но точно
#### Упражнения
##### 1. Какую семантику доставки вы выберете при построении следующих заданий? Почему?
Поиск наиболее популярных хэштегов в Твиттере: at-most-once, потому что важна быстрая обработка в реальном времени. Не страшно потерять точность.
Импортирование записей из потока данных в базу данных: at-least-once, потому что импорт скорее всего будет производиться операцией upsert - идемпотентной.
##### 2. В этой главе мы рассмотрели компонент анализатора использования в задании контроля за использованием системы и преобразовали его в идемпотентную операцию. А что вы скажете о компоненте блока записи данных об использовании? Является ли он идемпотентной операцией?
Зависит от реализации оператора. Если запись идёт в некий хэш, по ключу - скорее всего да, он идемпотентен.
