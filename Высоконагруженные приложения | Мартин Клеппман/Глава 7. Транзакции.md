# Глава 7. Транзакции
*Транзакция* — способ группировки приложением нескольких операций записи и чтения в одну логическую единицу. Все операции записи и чтения в ней выполняются как одна: вся транзакция или целиком выполняется успешно (с *фиксацией изменений*), или целиком завершается неудачно (с *прерыванием* и *откатом*).

Транзакции были созданы для *упрощения модели программирования приложений*, работающих с базами данных.

Возможные уровни изоляции: *чтение зафиксированных данных* (read committed), *изоляция снимков состояния* (snapshot isolation) и *сериализуемость* (serializability).

## 7.1. Неустоявшаяся концепция транзакции
Поддержка транзакций в современных SQL БД мало отличается от System R - первой.

### Смысл аббревиатуры ACID
**ACID**:  *атомарность* (Atomicity), *согласованность* (**C**onsistency), *изоляция* (**I**solation), *сохраняемость* (**D**urability*).

**BASE**: *"как правило, доступна"* (**B**asically **A**vailable), *"гибкое состояние"* (**S**oft state) и *"конечная согласованность"* (**E**ventual consistency).

#### Атомарность
По сути "прерываемость". Если операции записи сгруппированы в атомарную транзакцию и ее не удается завершить (зафиксировать изменения) из-за сбоя, то она *прерывается* (abort) и базе данных приходится отбросить или откатить все уже выполненные в рамках этой транзакции операции записи.

#### Согласованность
В любой момент момент времени данные должны оставаться корректными. Свойство приложения, а не БД. 

#### Изоляция
Конкурентно выполняемые транзакции изолированы друг от друга.

#### Сохраняемость
БД не теряет записанных (успешно зафиксированных) транзакций данных, даже в случае сбоя ПО или самой БД.

### Однообъектные и многообъектные операции
Атомарность и изоляция отдельных действий с отдельными объектами (например *сравнение с обменом*) - не транзакции. Транзакции - группировка **нескольких** операций.

Многообъектные транзакции необходимы для поддержания согласованости при обновлении строк из разных таблиц или полей в нескольких документах. Без атомарности усложнится обработка ошибок на стороне приложения, без изоляции - контроль конкурентного доступа.

#### Обработка ошибок и прерывание транзакций
При возникновении риска нарушения гарантий атомарности, изоляции или сохраняемости БД полностью отменит транзакцию. И её можно безопасно повторить. Но не всегда это лучший вариант: если транзакция была завершена успешна, а сбой произошел в сети при подтверждении клиенту; если сбой связан с перегрузкой; если ошибка повторяется (баг, а не мигание сети и т.п.); если у транзакции есть побочные действия вне базы данных.

## 7.2. Слабые уровни изоляции (277)
*Сериализуемая* изоляция означает гарантию базой данных такого режима выполнения транзакций, как будто они выполняются *последовательно*. Это дорого. Слабые уровни изоряции дают меньшие гарантии, но и стоят меньше.

### Чтение зафиксированных данных (read committed)
Самый базовый уровень изоляции транзакций. Две гарантии: клиент видит только зафиксированные данные (*грязное* чтение), можно перезаписывать только зафиксированные данные (нет *грязнаях* запись).

Для запрета грязной записи, прежде чем модифицировать объект (строку или документ), транзакция должна сначала установить на него блокировку и удерживать до фиксации или прерывания. Для запрета грязных чтений используется механизм типа Copy on Write.

### Изоляция снимков состояния и воспроизводимое чтение
Каждая транзакция читает данные из согласованного снимка состояния БД. То есть видит данные, которые были зафиксированы в базе на момент ее (транзакции) начала.

В реализации так же используются блокировки при записи, но не используются, за ненадобностью, при чтении. Чтение никогда не блокирует запись, а запись — чтение.

БД хранит несколько версий зафиксированных данных - подход *многоверсионного управления конкурентным доступом* (multiversion concurrency control, MVCC). Каждой транзакции присваивается монотонно возрастающий идентификатор, и она работает только с обьектами с меньшим значением, а создаёт - со своим. Версии, к которым уже не обратится ни одна из действущих транзакций, удаляются сборщиком мусора БД.

В Oracle называется уровнем *сериализации* (serializable), в PostgreSQL и MySQL — *воспроизводимым чтением* (repeatable read).

### Предотвращение потери обновлений
Проблема *потерянного обновления* (lost update) может возникать, когда две транзакции читают одно значение из базы данных, меняют его и записывают обратно (*цикл чтения изменения записи*). Есть риск потери одного из изменений, поскольку вторая операция записи не учитывает предыдущего изменения.

*Атомарные операции* записи позволяют выполнять изменения не в цикле чтение-изменение-запись. При использовании ORM, скорее всего, такие циклы всё равно будут возникать там, где возможно применение атомарных операций. Реализуются через блокировки. 

*Явные блокировки*, предназначенных для обновления объектов, позволяют выполнить цикл чтение-изменение-запись безопасно. 

*Автоматическое обнаружение потери обновлений* позволяет выполняться циклам чтения-изменения-записи конкурентно, но при обнаружениии потери обновления транзакция будет прервана и повторена.

*Сравнение с обменом* (compare-and-set) допускает обновление только значений, которые не менялись с момента их прошлого чтения. При несовпадении текущего значения с ранее прочитанным - цикл прервется и повторится. Применяется в безтранзакционных БД.

### Асимметрия записи и фантомы
*Асимметрии записи* (write skew) - фиксация нескольких транзакций, корректных по отдельности, но некорректные в сумме.

*Фантом* (phantom) - Эффект, при котором операция записи в одной транзакции меняет результат запроса на поиск в другой. Обычно возникает, когда не на что поставить блокировку.

Если не на что поставить блокировку для предотвращения ассиметрии - такой обьект можно создать. Например при бронировании можно блокировать не обьекты апартаментов, а записи отрезков времени в специально созданной для этого таблице. Она не хранит никакой информации, используется только для блокировок. Такой подход называется *материализацией конфликтов* (materializing conflicts)

## 7.3. Сериализуемость (298)
*Сериализуемость* (serializability) считается самым сильным уровнем изоляции. Гарантирует, что при конкурентном выполнении транзакций результат останется таким же, как при их последовательном выполнении. То есть база предотвращает все возможные состояния гонки.

Обычно реалиазуется через действительно последовательное выполнение транзакции, двухфазную блокировку или методы оптимистического управления конкурентным доступом.

### Последовательное выполнение
Все транзакции должны быть маленькими и быстрыми. Набор данных должен помещаться в памяти целиком. Пропускная способность по записи должна быть достаточно низкой для обработки на одном ядре CPU.

Запрещает интерактивные транзакции. Приложение заранее отправляет весь код транзакции в базу данных в виде *хранимой процедуры* (stored procedure).

Для масштабирования по записи придётся использовать секционирование.

### Двухфазная блокировка (2PL)
Допускается конкурентное чтение одного объекта несколькими транзакциями при условии, что никто его не записывает. Но для выполнения операции записи этого объекта (изменения или удаления) требуется монопольный доступ.

При двухфазной блокировке записывающие транзакции блокируют не просто другие записывающие транзакции, но и читающие и наоборот. Из-за частых блокировок возникают и *взаимные блокировки* (deadlock). Их отслеживает и разрешает БД.

Низкая производительность. 

### Сериализуемая изоляция снимков состояния (SSI)
Обеспечивает полную сериализуемость за счет небольшого снижения производительности по сравнению с обычной изоляцией снимков состояния.

*(SERIALAZABLE в PostgreSQL)*

Добавляет поверх изоляции снимков состояния алгоритм для обнаружения конфликтов сериализации между операциями записи и принятия решения о том, какие транзакции прервать.
