# Глава 6. Секционирование
В случае очень больших наборов данных или объемов обрабатываемой информации необходимо разбить их на *секции* (partitions), иначе говоря, выполнить *шардинг* (sharding) данных. Основная цель секционирования данных — масштабируемость.

## 6.1. Секционирование и репликация
Секционирование обычно совмещают с репликацией. Каждая запись относится только к одной секции, но храниться может на нескольких узлах в целях отказоустойчивости.

При репликации типа "ведущий-ведомый" в узле может храниться несколько секций. Тогда каждый узел выступает в качестве ведущего для одних секций и ведомого для других.

## 6.2. Секционирование данных типа "ключ — значение"
Цель секционирования — равномерно распределить по узлам данные и загрузку по запросам. Если секционирование выполнено неравномерно, оно называется *асимметричным* (skewed). Секция с непропорционально высокой нагрузкой называется *горячей точкой* (hot spot).

### Секционирование по диапазонам значений ключа
Один из методов секционирования — назначить каждой из секций непрерывный диапазон значений ключа. Диапазоны значений ключа не обязательно должны быть одинакового размера, поскольку данные могут быть распределены неравномерно. 

Недостатком секционирования по диапазонам значений ключа является то, что некоторые паттерны доступа приводят к горячим точкам. Например, при хранении и обработке потока данных по ключу даты/времени, самой нагруженной секцией будет последняя.

### Секционирование по хешу ключа
Хэш-функции обеспечивают более равномерное распределение данных по секциям. Но запросы по диапазонам становятся неэфективны, так как смежные ключи будут лежать в разных секциях.

### Асимметричные нагрузки и разгрузка горячих точек
Большинство систем не умеют автоматически выравнивать высоко асимметричную нагрузку, поэтому это обязанность приложения. Если известно, что конкретный ключ — очень горячий, простейшим решением будет добавление в начало или конец этого ключа случайного числа.

## 6.3. Секционирование и вторичные индексы
Вторичные индексы невозможно поставить в четкое соответствие секциям. Существует два основных подхода к секционированию базы данных с вторичными индексами: секционирование по документам (document-based partitioning) и секционирование по термам (term-based partitioning).

### Секционирование вторичных индексов по документам
При таком подходе к индексации все секции совершенно самостоятельны: каждая секция поддерживает свои собственные вторичные индексы, охватывающие только документы из этой секции. При необходимости выполнить запись в БД, приходится работать только с секцией в которой содержится идентификатор записываемого документа. Секционированный по документам индекс также называется *локальным индексом* (local index).

Чтение может потребовать запросов **ко всем** секциям. Такие запросы называются *фрагментированными* (scatter/gather).

### Секционирование вторичных индексов по термам
*Глобальный индекс* (global index) охватывает данные из всех секций. Такой индекс нельзя хранить в одном узле, иначе он превратится в узкое место. Глобальный индекс тоже нужно секционировать.

**Вопрос:** Глобальный индекс вторичных ключей может конфликтовать с основным индексом, первичного ключа?
**Вопрос:** Если первая секция хранит цвета [a-s] и марки [a-s], то куда попадёт "red toyouta" - в первую или вторую секцию?

## 6.4. Перебалансировка секций
Процесс перемещения нагрузки с одного узла в кластере на другой называется *перебалансировкой* (rebalancing).
- база данных должна продолжать принимать запросы на чтение и запись во время перебалансировки;
- после перебалансировки нагрузка должна быть распределена равномерно по узлам кластера;
- между узлами должно перемещаться ровно то количество данных, которое необходимо;

### Методики перебалансировки
#### Как делать не следует: хеширование по модулю N
При изменении количества N узлов придется перенести большинство ключей из одного узла в другой.
#### Фиксированное количество секций
Можно создать намного больше секций, чем узлов в системе, и распределить по нескольку секций на каждый узел. При добавлении нового узла, он заберет секции у предыдущих. Между узлами перемещаются только секции целиком. Количество последних не меняется, как и соответствие ключей секциям. Единственное, что меняется, — распределение секций по узлам. 
#### Динамическое секционирование
Когда размер секции перерастает заданный размер, она разбивается на две примерно равные. И наоборот, если секция становится меньше определенного значения, она объединяется с другой секцией. Каждая секция относится к какому-либо узлу, причем к одному узлу может относиться несколько секций. После разбиения большой секции одну из ее частей можно переместить в другой узел, чтобы сбалансировать нагрузку. Преимуществом динамического секционирования является адаптация количества секций к общему объему данных.
### Секционирование пропорционально количеству узлов
На каждый узел приходится фиксированное количество секций. При добавлении в кластер новый узел случайным образом выбирает фиксированное количество существующих секций для разбиения, после чего забирает по одной половине каждой из разбиваемых секций, оставляя вторые половины на месте. Такой подход обеспечивает практически постоянные размеры отдельных секций.

### Эксплуатация: автоматическая или ручная перебалансировка
Полностью автоматическая перебалансировка удобна тем, что уменьшает объем работ по обслуживанию системы. Однако ее результаты могут оказаться неожиданными. Присутствие человека может предотвратить операционные сюрпризы.

## 6.5. Маршрутизация запросов
> "По какому IP-адресу и к какому порту мне нужно подключиться, если я хочу прочитать или записать значение для ключа foo?"

Это частный случай более общей задачи, называемой *обнаружением сервисов* (service discovery). Есть несколько решений:
1. Разрешить клиентам обращаться к любому узлу. Если узел может обработать запрос, он сделает это, иначе - перенаправит.
2. Потребовать, чтобы клиенты сами учитывали секционирование и распределение секций по узлам.
3. Отправлять все поступающие от клиентов запросы сначала маршрутизирующему звену.

**Откуда отвечающий за маршрутизацию компонент знает об изменениях в распределении секций по узлам? ** 

Многие распределенные информационные системы используют для отслеживания метаданных кластера отдельный сервис координации, например ZooKeeper. Все узлы регистрируются в сервисе, который поддерживает актуальную карту соответствий секций узлам. При каждой смене узла-владельца секции или добавлении/удалении узла сервис оповещает маршрутизирующее звено, так что маршрутизация остается актуальной.

Некоторые системы используют для обмена сообщениями между узлами *gossip-протокол* для распространения всех изменений состояния кластера. Эта модель усложняет узлы базы
данных, но позволяет избежать зависимости от внешнего сервиса координации.