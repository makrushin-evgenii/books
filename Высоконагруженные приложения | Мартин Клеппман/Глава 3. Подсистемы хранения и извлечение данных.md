# Глава 3. Подсистемы хранения и извлечения данных
Представление о том, каковы внутренние механизмы функционирования подсистемы хранения, необходимо для выбора подходящей для конкретного приложения.

## 3.1. Базовые структуры данных БД
Журнал - файл, предназначенный только для добавления данных в его конец.
Индекс - структура, ускоряющая запросы на чтение, но замедляющая запись.

### Хеш-индекс
Наиболее простой тип индекстов, аналогичный структуры HashMap в языках программирования. Имеет два недостатка:
1. Запросы по диапазону неэффективны. Например, невозможно с легкостью просмотреть все записи между 00000 и 99999 — необходимо искать каждый ключ отдельно в хеш-картах
2. Хеш-таблица (как правило) должна помещаться в оперативной памяти

При записи только в конец файла-журнала, возможно исчерпание места на диске. Во избежание применяется несколько методов:
1. Разбивка журнала на сегменты определенного размера, закрывая файл сегмента при достижении им определенного размера и записывая последующие данные уже в новый файл
2. Уплотнение, что означает отбрасывание дублирующихся ключей из журнала и сохранение только последней версии данных для каждого ключа.
3. Объединение нескольких уплотнёных сегментов в один заданного размера.

Журнал с записью только в конец файла позволяет обходиться только последовательными операциями записи, которые почти всегда быстрее случайных. Позволяет конкурентный доступ и упрощает восстановление после сбоев.

### SS-таблицы и LSM-деревья
SS-таблица (SSTable, sorted string table) - отсортированная строковая таблица. Данные отсортированы по ключу, в сегментах ключи не повторяются. Преимущества такой структуры:
1. Объединение сегментов выполняется быстро и эффективно, даже если размер файлов превышает объем доступной оперативной памяти. Подход похож на сортировку слиянием: обьединяемые файлы читаются параллельно, в выходной файл записывается значение с наименьшим ключом.
2. Чтобы найти в файле конкретный ключ, не нужно больше хранить индекс всех ключей в оперативной памяти. Для поиска смещения ключа достаточно знать смещения двух его соседей (разреженный индекс).
3. При использовании разреженных индексов, блоки можно сжимать для экономии места на диске и снижения использования полосы пропускания ввода/вывода.

Подсистемы хранения, основанные на принципе слияния иуплотнения отсортированных файлов, часто называются LSM-подсистемами хранения.

То, что данные хранятся в отсортированном виде, дает возможность эффективно выполнять запросы по диапазонам, а поскольку записи на диск осуществляются последовательно, LSM-дерево способно поддерживать высокую пропускную способность по записи.
Алгоритм на основе LSM-дерева может работать медленно при поиске отсутствующих в базе данных ключей. Для оптимизации таких запросов применяется фильтр Блума - эффективно использующая память структура данных для
приближенного определения содержимого множества.

Для создания и поддержки SS-таблицы:
1. При поступлении записи добавляем ее в располагающуюся в оперативной памяти сбалансированную структуру данных (например, красно-черное дерево) - MemTable.
2. Когда размер MemTable превышает определенное пороговое значение — записываем его на диск в виде файла SS-таблицы. Новый файл SS-таблицы становится последним сегментом базы данных. Операции записи продолжают выполняться в новый экземпляр MemTable.
3. Для обслуживания запроса на чтение сначала пробуем найти ключ в MemTable, затем в последнем по времени сегменте на диске, затем в предпоследнем и т.д. .
4. Время от времени запускаем в фоне процесс слияния и уплотнения, чтобы объединить файлы сегментов и отбросить перезаписанные или удаленные значения.
5. Для восстановления MemTable после сбоев можно параллельно вести обычный, неупорядоченный журнал. 

### B-деревья
В отличие от журналируемых индексов, B-деревья разбивают БД на *блоки* или *страницы* фиксированного размера и читают/записывают по одной странице за раз. Такая конструкция лучше подходит для нижележащего аппаратного обеспечения, поскольку диски тоже разбиваются на блоки фиксированного размера. Все страницы имеют свой адрес/местоположение, благодаря чему одни страницы могут ссылаться на другие. 

Количество ссылок на дочерние страницы на одной странице B-дерева называется *коэффициентом ветвления* (branching factor). Четырехуровневое дерево страниц по 4 Кбайт с коэффициентом ветвления в 500 может хранить
до 256 Тбайт информации

*Разве грубина и соответственно поиск ключа не будет O(log^b(n))?, а не O(log(n))*

Чтобы сделать БД отказоустойчивой, реализации B-деревьев обычно включают дополнительную структуру данных на диске: *журнал упреждающей записи* (writeahead log, WAL), также именуемый *журналом повтора* (redo log). Он представляет собой файл, предназначенный только для добавления, в который все модификации B-деревьев должны записываться еще до того, как применяться к самим страницам дерева. Вместо перезаписи страниц и поддержания WAL некоторые базы данных используют схему копирования при записи (Copy-on-write, COW)

*Идея подхода copy-on-write заключается в том, что при чтении области данных используется общая копия, в случае изменения данных — создается новая копия.*

Конкурентный доступ обычно контролируется путем защиты структур данных дерева с помощью *защелок* (latch) — облегченного варианта блокировок. 

### Сравнение B- и LSM-деревье
**LSM-**: +последовательная запись, +легче упротняется, -процессы конкурируют за полосу ввода-вывода, -ключи могут лежать в нескольких местах
**B-**: -случайная запись, -больше фрагментация, +предсказуемая производительность, +ключи не дублируются

### Другие индексные структуры
Распространенной практикой является применение вторичных индексов (secondary index).

Запросы ищут в индексе ключ, а значение между тем может быть фактической искомой строкой (документом, вершиной) или ссылкой на строку, хранящуюся где-то в другом месте. Во втором случае место, где хранятся строки, называется *неупорядоченным файлом* (heap file), и данные там хранятся, соответственно, в неупорядоченном виде.

В некоторых случаях лишний переход от индекса к неупорядоченному файлу — слишком затратная вещь для чтения в смысле производительности, поэтому желательно хранить проиндексированную строку непосредственно в индексе. Такой вариант носит название *кластеризованного индекса* (clustered index).

Наиболее распространенный тип составных индексов — сцепленный индекс (concatenated index), который просто объединяет несколько полей в один ключ, присоединяя один столбец к другому. Многомерные индексы — более общий способ запроса нескольких столбцов сразу.

*Нечеткие* (fuzzy) запросы требуют применения других методов индексации.

Данные могут храниться в *размещаемых в оперативной памяти БД* (in-memory databases), если стоимость RAM не критична. Диск применяется только в качестве дописываемого журнала с целью обеспечить сохраняемость, а операции чтения выполняются только из оперативной памяти.

## 3.2. Обработка транзакций или аналитика?
OLTP - обработка транзакций в реальном времени, OLAP - аналитическая обработка данных в реальном времени.

Свойство|Системы обработки транзакций (OLTP)| Аналитические системы (OLAP)
-|-|-
Основной паттерн чтения|Неболькое количество записей на один запрос, извлекается по ключу|Агрегирование по большому количеству записей
Основной паттерн записи|Произвольный доступ|Групповой импорт или поток событий
В основном применяется|Конечными пользователями через веб-приложение|Аналитиками
Какие данные отражает|Актуальное состояние данных|Историю событий
Размер набора данных|От гигабайтов до терабайтов|От терабайтов до петабайтов

### Складирование данных
*Склад данных* (data warehouse) представляет собой отдельную БД, которую аналитики могут использовать, не влияя при этом на OLTP-операции. Склад содержит предназначенную только для чтения копию данных из всех различных OLTP-систем компании. Данные извлекаются из баз OLTP (с помощью выполнения периодических дампов данных или непрерывного потока обновлений данных), преобразуются в удобный для анализа вид, очищаются и затем загружаются в склад. Процесс их помещения в склад известен под названием *"извлечение—преобразование—загрузка"* (extract—transform—load, ETL)

### "Звезды" и "снежинки": схемы для аналитики
Множество складов данных применяются довольно шаблонным образом, известным под названием *"схема звезда"() (star schema, также моделирование с помощью измерений (dimensional modeling)). В центре схемы находится так называемая *таблица фактов*. Каждая строка таблицы отражает событие, произошедшее в конкретный момент времени. Отдельные столбцы таблиц фактов представляют собой атрибуты, другие - внешние ключи к другим таблицам, именуемым *таблицами измерений* (dimension table). В то время как строка в таблице фактов соответствует событию, измерения соответствуют "кто", "что", "где", "когда", "как" и "почему" этого события.

## 3.3. Столбцовое хранилище
Столбцовые хранилища хранит рядом значения не из одной строки, а из одного столбца. Если каждый столбец хранится в отдельном файле, то запросу требуется прочитать и выполнить синтаксический разбор только необходимых ему столбцов. Размещение данных по столбцам требует, чтобы файлы всех столбцов содержали строки в одинаковом порядке - так проще собрать полную строку.

### Сжатие столбцов
При малом количестве различных значений в столбце по сравнению с числом строк эфективно *кодирование с помощью битовой карты*. Если значений совсем немного - такие битовые карты могут хранить по одному биту на строку. Но если значений много, то в большинстве битовых карт будет много нулей (*разреженные*). Тогда стоит применить метод кодирования длин серий (например 00010 это 3 нуля 1 единица 1 ноль)

### Порядок сортировки в столбцовом хранилище
Если в основном столбце сортировки количество различных значений невелико, то после сортировки в нем появятся длинные последовательности повторяющихся одинаковых значений в строке. Они очень хорошо сжимаются кодированием длин серий.

Для оптимизации разного вида запросов может иметь смысл хранить несколько реплик набора данных с разными порядками сортировки.

### Запись в столбцовое хранилищ
Подход с обновлением данных на месте, используемый B-деревьями, невозможен в случае сжатых столбцов. При необходимости вставить строки в середине отсортированной таблицы, вероятнее всего, придется переписать все файлы столбцов. Вставка должна обновлять все столбцы согласованным образом, ведь строки определяются по их позиции в столбце. Решением может быть использование LSM-деревьев: все записывается сначала в хранилище в оперативной памяти, где данные добавляются в отсортированную структуру и подготавливаются к записи на диск. 

### Агрегирование: кубы данных и материализованные представления
*Материализованное представление* (materialized view) - копия результов запроса. Распространенный особый случай материализованного представления — *куб данных* (data cube), или *OLAP-куб* (OLAP cube). Он представляет собой сетку сводных показателей, сгруппированных по различным измерениям. Кубы могут иметь больше двух измерений.
