# Глава 4. Кодирование и эволюция
*обратная совместимость* — более новый код способен читать данные, записанные более старым; *прямая совместимость* — более старый код способен читать данные, записанные более новым.

## 4.1. Форматы кодирования данных
Преобразование из представления в памяти в последовательность байтов называется *кодированием* (encoding), или *сериализацией* (serialization), или *маршалингом* (marshalling), а обратная ему операция — *декодированием* (decoding), или *парсингом* (parsing), или *десериализацией* (deserialization), или *демаршалингом* (demarshalling)

### Форматы, ориентированные на конкретные языки
в Java есть пакет `java.io.Serializable`, в Python — `pickle` и т. д. . Их использование затрудняет интеграцию с внешними системами, написаными на других языках, а так же может работать не эффективно. Поэтому стоит использовать только для краткосрочных, неважных задач - сляпать что-то на коленке.

### JSON, XML и двоичные типы данных
Удобочитаемые для людей, но: кодирование чисел приводит к множеству неоднозначностей; не поддерживаются двоичные строки, из-за чего их приходится кодировать в base64, что занимает больше места;  

### Thrift и Protocol Buffers
Thrift и Protocol Buffers требуют наличия схемы для любых кодируемых данных. Включают утилиту генерации кода, получающую на входе описание схемы и генерирует классы, реализующие указанную схему на различных языках программирования. А код приложения затем может вызывать этот сгенерированный код для кодирования/декодирования записей схемы. При кодировании вместо названий используются *теги полей* (field tags) из схемы для экономии места.

Схемы неизбежно меняются с течением времени. Это называется *эволюцией схемы*. Можно поменять название поля в схеме, ведь закодированные данные никогда не ссылаются на названия полей, но нельзя поменять тег поля, так как из-за этого все существующие закодированные данные превратятся в неправильные. 

Прямая совместимость обеспечивается тем, что старый код может игнорировать значения с неизвестными ему тегами. Удаление поля ничем не отличается от его добавления, разве что обратная и прямая совместимости меняются местами. То есть можно удалять только необязательные поля и нельзя использовать один и тот же номер тега повторно.

### Avro
Avro тоже применяет схему для задания структуры кодируемых данных. Для синтаксического разбора двоичных данных необходимо пройти по полям в том порядке, в котором они встречаются в схеме, и получить из схемы тип данных каждого из полей. Любые различия схем между записывающим и читающим кодом будет означать неправильное декодирование данных.

*Схема для чтения* (reader’s schema) и *схема для записи* (writer’s schema) не обязательно должны совпадать — достаточно, чтобы они были совместимы. При декодировании (чтении) данных библиотека разрешает конфликты, сопоставляя схему для чтения и схему для записи и преобразовывая данные из одной в другую.

При работе с Avro прямая совместимость означает возможность сосуществования новой версии схемы для записи и старой для чтения. С другой стороны, обратная совместимость означает возможность сосуществования новой версии схемы для чтения и старой схемы для записи.

Файлы Avro самоописываемые, в том смысле что хранят всю необходимую для их чтения информацию.

### Достоинства схем
- База данных схем упрощает проверку прямой и обратной совместимости изменений схемы.
- Генерация кода для ЯП со статической типизацией.
- Могут быть компактнее "двоичного JSON".
- Схема — важный вид документации.

## 4.2. Режимы движения данных
### Поток данных через БД
Эволюция схемы, таким образом, позволяет базе данных быть представленной в таком виде, как будто она вся закодирована с помощью единой схемы, несмотря на то что в хранилище могут присутствовать записи, закодированные на основе различных версий этой схемы.

Если не быть аккуратными, то можно потерять данные при обновлении старой версией приложения данных, ранее записанных более новой его версией.

Время жизни данных превышает время жизни кода.

### Поток данных через сервисы: REST и RPC
Сервер сам может служить клиентом для другого сервера. Такой подход часто используется для декомпозиции больших приложений на небольшие сервисы по областям функциональности. Подобный метод создания приложений традиционно назывался *сервисориентированной архитектурой* (service-oriented architecture, SOA), а в последнее время подвергся пересмотру и получил новое название: *микросервисная архитектура* (microservices architecture)

В отличии от баз данных, сервисы предоставляют API, свой для каждого приложения, допускающий только предопределенные бизнес-логикой (кодом приложения) сервиса входные и выходные данные. Главная цель сервис-ориентированной и микросервисной архитектур — облегчить изменение и поддержку приложения путем обеспечения независимого развертывания и развития сервисов. Если в качестве базового протокола для связи с сервисом используется HTTP, то такой сервис называется *веб-сервисом*.

Существует два популярных подхода к проектированию веб-сервисов: *REST* и *SOAP*:
- REST не протокол, а скорее подход к проектированию, основанный на принципах HTTP. Он делает акцент на простых форматах данных, применении URL для идентификации ресурсов и использовании возможностей HTTP для управления кэшем, аутентификации и согласования типа контента. API, спроектированный в соответствии с принципами REST, называют RESTful.
- SOAP — основанный на формате XML протокол для выполнения запросов к сетевым API. API SOAP веб-сервиса описывается с помощью языка описания веб-сервисов (web services description language, WSDL), основанного на XML. Он позволяет генерировать код, так что клиент может обращаться к удаленным сервисам путем локальных классов и вызовов методов.

Основная идея модели *удаленного вызова процедуры* (remote procedure call, RPC) состоит в том, что выполнение запроса к удаленному сетевому сервису должно выглядеть так же, как и вызов функции или метода на обычном языке программирования, в пределах одного процесса (эта абстракция называется *независимостью от расположения* (location transparency)). Но сетевой запрос сильно отличается от локального вызова функции:
- в случае повторного вызова неудавшихся запросов нужно учитывать, что предыдущие могли были доставлены и выполнены, просто не доставили ответы - в следствии чего произойдёт повторное выполнение действия;
- может не вернуть ответ вследвие ошибки, сетевой проблемы или *превышения времени ожидания* (time-out);
- время выполнения зависит часто от неконтролируемых нами обстоятельств.

Некоторые RPC фреймворки также включают *обнаружение сервисов* (service discovery) — позволяют клиентам искать, на каких IP-адресах и портах работает конкретный сервис

REST - основной стиль общедоступных API. RPC-фреймворки сосредоточены в основном на запросах, выполняемых между сервисами, принадлежащими одной организации.

### Поток данных передачи сообщений
*Cистемы асинхронной передачи сообщений* (asynchronous message-passing system) — нечто среднее между RPC и базами данных. Они схожи с RPC в том, что запрос от клиента (обычно называемый *сообщением* (message)) доставляется другому процессу без особой задержки. Они напоминают БД тем, что сообщение не отправляется непосредственно через сетевое соединение, а проходит через посредника, именуемого *брокером сообщений* (message broker), или *очередью сообщений* (message queue), которая временно хранит сообщение. 

+ служит в качестве буфера в случае недоступности или перегруженности получателя;
+ может автоматически отправлять сообщения повторно сбойным процессам;
+ отправителю не требуется знать IP-адрес и номера порта получателя;
+ обеспечивает возможность отправки одного сообщения нескольким получателям;
+ логически расцепляет отправителя с получателем.

Взаимодействие чаще всего одностороннее: отправитель обычно не ждет ответа на свои сообщения. Брокеры сообщений обычно используются следующим образом: один процесс отправляет сообщение, предназначенное для определенной *очереди* (queue) или *топика* (topic), а брокер обеспечивает доставку данного сообщения одному или нескольким *потребителям* (consumers) или *подписчикам* (subscribers) этой очереди или топика.  В одной очереди может быть много *производителей* (producers) и много *потребителей* сообщений.

*Акторная модель* (actor model) — модель программирования для создания конкурентного доступа в пределах одного процесса. Логика инкапсулируется в *акторах*. Каждый актор обычно соответствует одному клиенту или сущности, у него может быть свое локальное состояние (не разделяемое ни с какими другими акторами), и он взаимодействует с другими акторами путем отправки и получения асинхронных сообщений. Доставка сообщений не гарантируется. Поскольку каждый актор обрабатывает одновременно только одно сообщение, нет необходимости заботиться о потоках выполнения.

В *распределенных акторных фреймворках* эта модель программирования используется для масштабирования приложения на несколько узлов. Распределенные акторные фреймворки, по сути, объединяют в одном фреймворке
брокер сообщений и акторную модель программирования.